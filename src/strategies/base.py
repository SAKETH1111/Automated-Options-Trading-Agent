"""Base strategy class and signal definition"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional

from loguru import logger


@dataclass
class StrategySignal:
    """Signal generated by a strategy"""
    
    # Identity
    signal_id: str
    strategy_name: str
    symbol: str
    action: str  # "open", "close", "roll", "adjust"
    timestamp: datetime = field(default_factory=datetime.now)
    
    # Trade Details
    legs: List[Dict] = field(default_factory=list)  # List of option legs
    
    # Strategy Parameters
    params: Dict = field(default_factory=dict)
    
    # Market Context
    market_snapshot: Dict = field(default_factory=dict)
    
    # Expected Outcomes
    max_profit: float = 0.0
    max_loss: float = 0.0
    probability_of_profit: float = 0.0
    expected_credit: float = 0.0
    
    # Risk Metrics
    risk_reward_ratio: float = 0.0
    delta_exposure: float = 0.0
    theta_exposure: float = 0.0
    vega_exposure: float = 0.0
    
    # Quality Score
    signal_quality: float = 0.0  # 0-100
    
    # Reasons/Notes
    reason: str = ""
    notes: str = ""
    
    # Filters Passed
    filters_passed: Dict = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """Convert signal to dictionary"""
        return {
            "signal_id": self.signal_id,
            "strategy_name": self.strategy_name,
            "symbol": self.symbol,
            "timestamp": self.timestamp.isoformat(),
            "action": self.action,
            "legs": self.legs,
            "params": self.params,
            "market_snapshot": self.market_snapshot,
            "max_profit": self.max_profit,
            "max_loss": self.max_loss,
            "probability_of_profit": self.probability_of_profit,
            "expected_credit": self.expected_credit,
            "risk_reward_ratio": self.risk_reward_ratio,
            "delta_exposure": self.delta_exposure,
            "theta_exposure": self.theta_exposure,
            "vega_exposure": self.vega_exposure,
            "signal_quality": self.signal_quality,
            "reason": self.reason,
            "notes": self.notes,
            "filters_passed": self.filters_passed,
        }


class Strategy(ABC):
    """Base class for all trading strategies"""
    
    def __init__(self, name: str, config: Dict):
        self.name = name
        self.config = config
        self.enabled = config.get("enabled", True)
        logger.info(f"Initialized strategy: {name}")
    
    @abstractmethod
    def generate_signals(
        self,
        symbol: str,
        stock_data: Dict,
        options_chain: List[Dict]
    ) -> List[StrategySignal]:
        """
        Generate trading signals based on market data
        
        Args:
            symbol: Stock symbol
            stock_data: Current stock data (price, IV, etc.)
            options_chain: Enriched options chain data
        
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def should_exit(
        self,
        trade: Dict,
        current_positions: List[Dict],
        current_pnl: float,
        current_pnl_pct: float
    ) -> Optional[Dict]:
        """
        Determine if a position should be exited
        
        Args:
            trade: Trade record from database
            current_positions: Current position data
            current_pnl: Current P&L in dollars
            current_pnl_pct: Current P&L as percentage
        
        Returns:
            Exit signal dict if position should be closed, None otherwise
        """
        pass
    
    @abstractmethod
    def should_roll(
        self,
        trade: Dict,
        current_positions: List[Dict],
        options_chain: List[Dict]
    ) -> Optional[Dict]:
        """
        Determine if a position should be rolled
        
        Args:
            trade: Trade record from database
            current_positions: Current position data
            options_chain: Available options chain
        
        Returns:
            Roll signal dict if position should be rolled, None otherwise
        """
        pass
    
    def _filter_by_dte(
        self,
        options: List[Dict],
        min_dte: int,
        max_dte: int
    ) -> List[Dict]:
        """Filter options by days to expiration"""
        return [
            opt for opt in options
            if min_dte <= opt["dte"] <= max_dte
        ]
    
    def _filter_by_delta(
        self,
        options: List[Dict],
        min_delta: float,
        max_delta: float
    ) -> List[Dict]:
        """Filter options by delta range"""
        return [
            opt for opt in options
            if min_delta <= opt["delta"] <= max_delta
        ]
    
    def _filter_by_liquidity(
        self,
        options: List[Dict],
        min_oi: int,
        min_volume: int,
        max_spread_pct: float
    ) -> List[Dict]:
        """Filter options by liquidity criteria"""
        return [
            opt for opt in options
            if (opt["open_interest"] >= min_oi and
                opt["volume"] >= min_volume and
                opt["spread_pct"] <= max_spread_pct)
        ]
    
    def _calculate_spread_metrics(
        self,
        short_leg: Dict,
        long_leg: Dict
    ) -> Dict:
        """Calculate metrics for a spread"""
        try:
            # Credit received (per contract)
            short_credit = short_leg["mid"]
            long_debit = long_leg["mid"]
            net_credit = short_credit - long_debit
            
            # Max loss
            width = abs(short_leg["strike"] - long_leg["strike"])
            max_loss = (width - net_credit) * 100  # Per contract
            
            # Max profit
            max_profit = net_credit * 100  # Per contract
            
            # Risk/reward ratio
            risk_reward = max_loss / max_profit if max_profit > 0 else 0
            
            # Probability of profit (approximate using delta)
            pop = 1 - abs(short_leg["delta"])
            
            # Greeks exposure
            delta_exposure = short_leg["delta"] + long_leg["delta"]
            theta_exposure = short_leg["theta"] + long_leg["theta"]
            vega_exposure = short_leg["vega"] + long_leg["vega"]
            
            return {
                "net_credit": net_credit,
                "max_profit": max_profit,
                "max_loss": max_loss,
                "risk_reward": risk_reward,
                "probability_of_profit": pop,
                "delta_exposure": delta_exposure,
                "theta_exposure": theta_exposure,
                "vega_exposure": vega_exposure,
                "width": width,
            }
        
        except Exception as e:
            logger.error(f"Error calculating spread metrics: {e}")
            return {}
    
    def _calculate_signal_quality(
        self,
        metrics: Dict,
        stock_data: Dict,
        filters_passed: Dict
    ) -> float:
        """
        Calculate overall signal quality score (0-100)
        Based on multiple factors
        """
        try:
            score = 0.0
            
            # Risk/Reward (0-25 points)
            # Target: 2-4 risk/reward ratio
            rr = metrics.get("risk_reward", 0)
            if 2 <= rr <= 4:
                score += 25 * (1 - abs(rr - 3) / 1)
            elif rr < 2:
                score += 15
            
            # Probability of Profit (0-25 points)
            pop = metrics.get("probability_of_profit", 0)
            if pop >= 0.7:
                score += 25
            elif pop >= 0.6:
                score += 20
            elif pop >= 0.5:
                score += 15
            
            # IV Rank (0-20 points)
            # Prefer higher IV rank for premium selling
            iv_rank = stock_data.get("iv_rank", 50)
            if iv_rank >= 50:
                score += 20 * (iv_rank - 50) / 50
            
            # Liquidity (0-15 points)
            liquidity = filters_passed.get("liquidity", False)
            if liquidity:
                score += 15
            
            # Delta (0-15 points)
            # Prefer lower delta exposure for neutral strategies
            delta_exp = abs(metrics.get("delta_exposure", 0))
            if delta_exp <= 0.05:
                score += 15
            elif delta_exp <= 0.10:
                score += 10
            elif delta_exp <= 0.15:
                score += 5
            
            return round(min(score, 100), 2)
        
        except Exception as e:
            logger.error(f"Error calculating signal quality: {e}")
            return 50.0

